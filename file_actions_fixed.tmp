import curses
import mimetypes
import os
import selectors
import shlex
import shutil
import subprocess
import threading
import time
import zipfile
from typing import Optional, cast, Any, List, Tuple

from config import HandlerSpec


class ExecutionJob:
    def __init__(self, filepath: str, command: List[str], display: str, mode: str):
        self.filepath = filepath
        self.command = command
        self.display = display
        self.mode = mode
        self.process: Optional[subprocess.Popen[str]] = None
        self.thread: Optional[threading.Thread] = None
        self.cancelled = False
        self.exit_code: Optional[int] = None
        self.started_at = time.time()
        self.done_event = threading.Event()

    def is_running(self) -> bool:
        if self.process is None:
            return False
        return self.process.poll() is None

    def mark_process(self, process: subprocess.Popen[str]) -> None:
        self.process = process

    def mark_finished(self, exit_code: Optional[int]) -> None:
        self.exit_code = exit_code
        self.done_event.set()

    def wait(self, timeout: Optional[float] = None) -> Optional[int]:
        self.done_event.wait(timeout)
        return self.exit_code

    def terminate(self) -> None:
        if self.process is None:
            return
        if self.process.poll() is not None:
            return
        self.cancelled = True
        try:
            self.process.terminate()
        except Exception:
            pass
        try:
            self.process.wait(timeout=2)
        except Exception:
            try:
                self.process.kill()
            except Exception:
                pass


class FileActionService:
    def __init__(self, navigator):
        self.nav = navigator

    # === Helpers ===
    def _resolve_base_directory(self, base_path: Optional[str]) -> str:
        if base_path:
            candidate = os.path.realpath(base_path)
            if os.path.isdir(candidate):
                return candidate
        return self.nav.dir_manager.current_path

    def _prompt_for_input(self, prompt: str) -> Optional[str]:
        stdscr_opt = self.nav.renderer.stdscr
        if stdscr_opt is None:
            return None
        stdscr = cast(Any, stdscr_opt)

        max_y, max_x = stdscr.getmaxyx()

        if max_y < 2 or max_x < 20:
            curses.flash()
            self.nav.need_redraw = True
            return None

        prompt_y = max_y - 1
        input_str = ""

        stdscr.move(prompt_y, 0)
        stdscr.clrtoeol()

        try:
            stdscr.addstr(prompt_y, 0, prompt[: max_x - 1])
        except curses.error:
            pass

        try:
            stdscr.timeout(-1)
            input_x = len(prompt)
            max_input_width = max(10, max_x - input_x - 1)

            stdscr.move(prompt_y, 0)
            stdscr.clrtoeol()
            stdscr.addstr(prompt_y, 0, prompt)
            stdscr.refresh()

            while True:
                key = stdscr.getch()

                if key in (10, 13, curses.KEY_ENTER):
                    break
                if key == 27:
                    input_str = ""
                    break
                if key in (curses.KEY_BACKSPACE, 127, 8):
                    if input_str:
                        input_str = input_str[:-1]
                elif 32 <= key <= 126 and len(input_str) < max_input_width:
                    input_str += chr(key)

                stdscr.move(prompt_y, 0)
                stdscr.clrtoeol()
                display_str = prompt + input_str
                stdscr.addstr(prompt_y, 0, display_str[: max_x - 1])
                stdscr.refresh()
        except KeyboardInterrupt:
            input_str = ""
        except Exception:
            input_str = ""
        finally:
            stdscr.timeout(40)
            self.nav.need_redraw = True

        result = input_str.strip()
        return result or None

    def prompt_confirmation(self, message: str) -> bool:
        message = message.strip()
        if not message:
            return False
        if message[-1] not in "?:":
            message = f"{message}?"
        prompt = f"{message} (y/N): "
        response = self._prompt_for_input(prompt)
        if response is None:
            return False
        normalized = response.strip().lower()
        return normalized in {"y", "yes"}

    # === File operations ===
    def open_file(self, filepath: str):
        if filepath.endswith(".zip"):
            stdscr_opt = self.nav.renderer.stdscr
            if stdscr_opt is None:
                curses.flash()
                self.nav.need_redraw = True
                return
            stdscr = cast(Any, stdscr_opt)
            max_y, max_x = stdscr.getmaxyx()
            try:
                filename = os.path.basename(filepath)
                base_name = os.path.splitext(filename)[0]
                extract_dir = os.path.join(self.nav.dir_manager.current_path, base_name)
                os.makedirs(extract_dir, exist_ok=True)

                status = f"Unzipping {filename} in progress..."
                stdscr.move(max_y - 1, 0)
                stdscr.clrtoeol()
                stdscr.addstr(max_y - 1, 0, status[: max_x - 1], curses.A_BOLD)
                stdscr.refresh()

                with zipfile.ZipFile(filepath) as zf:
                    members = zf.infolist()
                    total = len(members)
                    for i, member in enumerate(members):
                        zf.extract(member, extract_dir)
                        if (i + 1) % 10 == 0 or i + 1 == total:
                            status = f"Unzipping {filename}: {i + 1}/{total}"
                            stdscr.move(max_y - 1, 0)
                            stdscr.clrtoeol()
                            stdscr.addstr(
                                max_y - 1, 0, status[: max_x - 1], curses.A_BOLD
                            )
                            stdscr.refresh()
            except Exception:
                curses.flash()
            self.nav.need_redraw = True
            return

        mime_type, _ = mimetypes.guess_type(filepath)
        _, ext = os.path.splitext(filepath)

        handled = False
        is_text_like = False
        try:
            if ext == ".csv":
                handled = self._invoke_handler(
                    self.nav.config.get_handler_spec("csv_viewer"),
                    filepath,
                    default_strategy="terminal",
                )
            elif ext == ".parquet":
                handled = self._invoke_handler(
                    self.nav.config.get_handler_spec("parquet_viewer"),
                    filepath,
                    default_strategy="terminal",
                )
            elif mime_type == "application/pdf":
                handled = self._invoke_handler(
                    self.nav.config.get_handler_spec("pdf_viewer"),
                    filepath,
                    default_strategy="external_background",
                )
            elif mime_type and mime_type.startswith("image/"):
                handled = self._invoke_handler(
                    self.nav.config.get_handler_spec("image_viewer"),
                    filepath,
                    default_strategy="external_background",
                )
            else:
                is_text_like = bool(
                    (mime_type and mime_type.startswith("text/"))
                    or ext.lower()
                    in {
                        ".py",
                        ".txt",
                        ".md",
                        ".json",
                        ".yaml",
                        ".yml",
                        ".toml",
                        ".cfg",
                        ".ini",
                        ".sh",
                        ".c",
                        ".cpp",
                        ".h",
                        ".hpp",
                    }
                )
                handled = self._invoke_handler(
                    self.nav.config.get_handler_spec("editor"),
                    filepath,
                    default_strategy="external_foreground",
                )
        except FileNotFoundError:
            pass
        finally:
            if not handled and is_text_like:
                handled = self._open_with_vim(filepath)

            if not handled:
                self.nav.status_message = "No handler configured"
                curses.flash()
            self.nav.need_redraw = True

    def _open_with_vim(self, filepath: str) -> bool:
        stdscr_opt = self.nav.renderer.stdscr
        if stdscr_opt is not None:
            try:
                curses.def_prog_mode()
            except curses.error:
                pass
            try:
                curses.endwin()
            except curses.error:
                pass

        try:
            cmd = "vim"
            if shutil.which(cmd):
                try:
                    subprocess.call([cmd, filepath])
                    return True
                except Exception:
                    pass
        finally:
            if stdscr_opt is not None:
                try:
                    curses.reset_prog_mode()
                except curses.error:
                    pass
                try:
                    curses.curs_set(0)
                except curses.error:
                    pass
                try:
                    stdscr = cast(Any, stdscr_opt)
                    stdscr.refresh()
                except Exception:
                    pass

        return False

    def _invoke_handler(
        self,
        spec: HandlerSpec,
        filepath: str,
        *,
        default_strategy: str,
    ) -> bool:
        if not spec.commands:
            return False

        if spec.is_internal:
            return self._run_internal_handler(spec.commands, filepath)

        if default_strategy == "terminal":
            return self._run_terminal_handlers(spec.commands, filepath)
        if default_strategy == "external_foreground":
            return self._run_external_handlers(
                spec.commands,
                filepath,
                background=False,
            )
        if default_strategy == "external_background":
            return self._run_external_handlers(
                spec.commands,
                filepath,
                background=True,
            )

        return False

    def _run_external_handlers(
        self,
        handlers: List[List[str]],
        filepath: str,
        *,
        background: bool,
    ) -> bool:
        if not handlers:
            return False

        for raw_cmd in handlers:
            tokens = self._expand_command(raw_cmd, filepath)
            if not tokens:
                continue

            cmd_name = tokens[0]
            if shutil.which(cmd_name) is None:
                continue

            try:
                if background:
                    subprocess.Popen(
                        tokens,
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        stdin=subprocess.DEVNULL,
                        preexec_fn=os.setsid,
                    )
                else:
                    subprocess.call(tokens)
                return True
            except FileNotFoundError:
                continue
            except Exception:
                continue

        return False

    def _run_terminal_handlers(self, handlers: List[List[str]], filepath: str) -> bool:
        if not handlers:
            return False

        for raw_cmd in handlers:
            tokens = self._expand_command(raw_cmd, filepath)
            if not tokens:
                continue

            if self.nav.open_terminal(None, tokens):
                return True

        return False

    def _run_internal_handler(
        self, handlers: List[List[str]], filepath: str
    ) -> bool:
        stdscr_opt = getattr(self.nav.renderer, "stdscr", None)

        if stdscr_opt is not None:
            try:
                curses.def_prog_mode()
            except curses.error:
                pass
            try:
                curses.endwin()
            except curses.error:
                pass

        succeeded = False
        attempted = False
        last_cmd = None

        try:
            for raw_cmd in handlers:
                tokens = self._expand_command(raw_cmd, filepath)
                if not tokens:
                    continue

                if shutil.which(tokens[0]) is None:
                    continue

                attempted = True
                last_cmd = tokens[0]

                try:
                    return_code = subprocess.call(tokens)
                except FileNotFoundError:
                    continue
                except Exception:
                    continue

                if return_code == 0:
                    succeeded = True
                    break
        finally:
            if stdscr_opt is not None:
                try:
                    curses.reset_prog_mode()
                except curses.error:
                    pass
                try:
                    curses.curs_set(0)
                except curses.error:
                    pass
                try:
                    stdscr = cast(Any, stdscr_opt)
                    stdscr.refresh()
                except Exception:
                    pass

        if succeeded:
            cmd_display = last_cmd or "handler"
            self.nav.status_message = f"Handler exited: {cmd_display}"
            self.nav.need_redraw = True
            return True

        if attempted:
            cmd_display = last_cmd or "handler"
            self.nav.status_message = f"Handler failed: {cmd_display}"
            self.nav.need_redraw = True
            curses.flash()
            return True

        return False

    def _expand_command(self, raw_cmd: List[str], filepath: str) -> List[str] | None:
        if not raw_cmd:
            return None

        tokens: List[str] = []
        has_placeholder = False

        for part in raw_cmd:
            if not isinstance(part, str):
                continue
            replaced = part.replace("{file}", filepath)
            if replaced != part:
                has_placeholder = True
            tokens.append(replaced)

        if not tokens:
            return None

        if not has_placeholder:
            tokens.append(filepath)

        return tokens

    def run_execution(self, filepath: str) -> bool:
        if not filepath or not os.path.isfile(filepath):
            self.nav.status_message = "Not a file"
            curses.flash()
            self.nav.need_redraw = True
            return False

        existing_job = getattr(self.nav, "active_execution_job", None)
        if existing_job is not None and isinstance(existing_job, ExecutionJob) and existing_job.is_running():
            self.nav.status_message = "Execution already in progress"
            curses.flash()
            self.nav.need_redraw = True
            return False

        command, mode, error = self._resolve_execution_command(filepath)
        if not command:
            self.nav.status_message = error or "Unable to execute file"
            curses.flash()
            self.nav.need_redraw = True
            return False

        assert mode is not None
        mode_value = cast(str, mode)

        cwd = os.path.dirname(filepath) or self.nav.dir_manager.current_path
        display = shlex.join(command)
        job = ExecutionJob(filepath, command, display, mode_value)

        try:
            process = subprocess.Popen(
                command,
                cwd=cwd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.DEVNULL,
                text=True,
                encoding="utf-8",
                errors="replace",
                bufsize=1,
            )
        except FileNotFoundError:
            self.nav.status_message = f"Executor not found: {command[0]}"
            curses.flash()
            self.nav.need_redraw = True
            return False
        except Exception as exc:
            self.nav.status_message = f"Failed to launch: {exc.__class__.__name__}"
            curses.flash()
            self.nav.need_redraw = True
            return False

        job.mark_process(process)
        self.nav.set_active_execution_job(job)
        header = f"Running: {display}  (ESC to cancel)"
        self.nav.open_command_popup(header, [])

        thread = threading.Thread(target=self._monitor_execution_job, args=(job,), daemon=True)
        job.thread = thread
        thread.start()
        return True

    def _resolve_execution_command(
        self, filepath: str
    ) -> Tuple[Optional[List[str]], Optional[str], Optional[str]]:
        _, ext = os.path.splitext(filepath)
        ext = ext.lower()

        if ext == ".py":
            python_cmd = self.nav.config.get_executor("python")
            if not python_cmd:
                return None, None, "Python executor unavailable"
            tokens = self._prepare_python_command(python_cmd, filepath)
            if not tokens:
                return None, None, "Python executor misconfigured"
            return tokens, "python", None

        if ext:
            return None, None, "File type not supported for execution"

        if not os.access(filepath, os.X_OK):
            return None, None, "File is not executable"

        shell_cmd = self.nav.config.get_executor("shell")
        if not shell_cmd:
            return None, None, "Shell executor unavailable"
        tokens = self._prepare_shell_command(shell_cmd, filepath)
        if not tokens:
            return None, None, "Shell executor misconfigured"
        return tokens, "shell", None

    def _prepare_python_command(self, base_cmd: List[str], filepath: str) -> List[str]:
        return self._expand_command(base_cmd, filepath) or []

    def _prepare_shell_command(self, base_cmd: List[str], filepath: str) -> List[str]:
        if not base_cmd:
            return []

        target = os.path.basename(filepath)
        if not target:
            return []

        relative_target = f"./{target}"
        quoted_target = shlex.quote(relative_target)

        tokens: List[str] = []
        has_placeholder = False

        for part in base_cmd:
            if not isinstance(part, str):
                continue
            if "{file}" in part:
                has_placeholder = True
                tokens.append(part.replace("{file}", quoted_target))
            else:
                tokens.append(part)

        if not tokens:
            return []

        if not has_placeholder:
            tokens.append(quoted_target)

        return tokens

    def _monitor_execution_job(self, job: ExecutionJob) -> None:
        process = job.process
        if process is None:
            return

        selector = selectors.DefaultSelector()

        def register_stream(stream, label):
            if stream is None:
                return
            try:
                selector.register(stream, selectors.EVENT_READ, data=label)
            except Exception:
                pass

        register_stream(process.stdout, "stdout")
        register_stream(process.stderr, "stderr")

        try:
            while True:
                if process.poll() is not None and not selector.get_map():
                    break

                events = selector.select(timeout=0.1)

                if not events:
                    if process.poll() is not None:
                        break
                    continue

                for key, _ in events:
                    label = key.data
                    stream = cast(Any, key.fileobj)
                    try:
                        chunk = stream.readline()  # type: ignore[attr-defined]
                    except Exception:
                        chunk = ""

                    if not chunk:
                        try:
                            selector.unregister(stream)
                        except Exception:
                            pass
                        continue

                    line = chunk.rstrip("\n")
                    formatted = self._format_stream_line(label, line)
                    self.nav.append_command_popup_lines([formatted])

            # Drain remaining buffered output after process finishes
            for label, stream in (("stdout", process.stdout), ("stderr", process.stderr)):
                if stream is None:
                    continue
                try:
                    remaining = cast(Any, stream).read()  # type: ignore[attr-defined]
                except Exception:
                    remaining = ""
                if not remaining:
                    continue
                for raw_line in remaining.splitlines():
                    formatted = self._format_stream_line(label, raw_line.rstrip("\n"))
                    self.nav.append_command_popup_lines([formatted])
        finally:
            for stream in (process.stdout, process.stderr):
                if stream and not stream.closed:
                    try:
                        stream.close()
                    except Exception:
                        pass
            try:
                selector.close()
            except Exception:
                pass

        exit_code = process.poll()
        if exit_code is None:
            try:
                exit_code = process.wait()
            except Exception:
                exit_code = process.returncode

        job.mark_finished(exit_code)

        if getattr(self.nav, "active_execution_job", None) is job:
            self.nav.clear_active_execution_job()

        with self.nav.command_popup_lock:
            empty_output = len(self.nav.command_popup_lines) == 0

        if empty_output:
            self.nav.append_command_popup_lines(["(no output)"])

        if job.cancelled:
            header = f"Cancelled: {job.display}"
        elif exit_code == 0:
            header = f"Completed (exit 0): {job.display}"
        else:
            header = f"Failed (exit {exit_code}): {job.display}"

        self.nav.update_command_popup_header(header)

    @staticmethod
    def _format_stream_line(channel: str, text: str) -> str:
        if channel == "stderr":
            return f"[stderr] {text}" if text else "[stderr]"
        return text

    def create_new_file(self):
        filename = self._prompt_for_input("New file: ")
        if not filename:
            return

        base_dir = self.nav.dir_manager.current_path
        unique_name = self.nav.input_handler._get_unique_name(base_dir, filename)
        filepath = os.path.join(base_dir, unique_name)

        try:
            with open(filepath, "w"):
                pass
            os.utime(filepath, None)
        except Exception as e:
            stdscr = cast(Any, self.nav.renderer.stdscr)
            if stdscr:
                max_y, max_x = stdscr.getmaxyx()
                prompt_y = max_y - 1
                stdscr.addstr(
                    prompt_y,
                    0,
                    f"Error creating file: {str(e)[: max_x - 20]}",
                    curses.A_BOLD,
                )
                stdscr.clrtoeol()
                stdscr.refresh()
                stdscr.getch()
            return

        self.nav.notify_directory_changed(base_dir)
        self.open_file(filepath)

    def create_new_file_no_open(self, base_path: Optional[str] = None):
        filename = self._prompt_for_input("New file: ")
        if not filename:
            return

        base_dir = self._resolve_base_directory(base_path)
        unique_name = self.nav.input_handler._get_unique_name(base_dir, filename)
        filepath = os.path.join(base_dir, unique_name)

        try:
            with open(filepath, "w"):
                pass
            os.utime(filepath, None)
        except Exception as e:
            stdscr = cast(Any, self.nav.renderer.stdscr)
            if stdscr:
                max_y, max_x = stdscr.getmaxyx()
                prompt_y = max_y - 1
                stdscr.addstr(
                    prompt_y,
                    0,
                    f"Error creating file: {str(e)[: max_x - 20]}",
                    curses.A_BOLD,
                )
                stdscr.clrtoeol()
                stdscr.refresh()
                stdscr.getch()
            return

        self.nav.notify_directory_changed(base_dir)
        self.nav.status_message = f"Created file: {unique_name}"

    def create_new_directory(self, base_path: Optional[str] = None):
        dirname = self._prompt_for_input("New dir: ")
        if not dirname:
            return

        base_dir = self._resolve_base_directory(base_path)
        unique_name = self.nav.input_handler._get_unique_name(base_dir, dirname)
        dirpath = os.path.join(base_dir, unique_name)

        try:
            os.makedirs(dirpath)
        except Exception as e:
            stdscr = cast(Any, self.nav.renderer.stdscr)
            if stdscr:
                max_y, max_x = stdscr.getmaxyx()
                prompt_y = max_y - 1
                stdscr.addstr(
                    prompt_y,
                    0,
                    f"Error creating dir: {str(e)[: max_x - 20]}",
                    curses.A_BOLD,
                )
                stdscr.clrtoeol()
                stdscr.refresh()
                stdscr.getch()
            return

        self.nav.notify_directory_changed(base_dir)
        self.nav.status_message = f"Created directory: {unique_name}"

    def rename_selected(self):
        stdscr_opt = self.nav.renderer.stdscr
        if stdscr_opt is None:
            return
        stdscr = cast(Any, stdscr_opt)

        max_y, max_x = stdscr.getmaxyx()

        if max_y < 2 or max_x < 20:
            curses.flash()
            self.nav.need_redraw = True
            return

        items = self.nav.build_display_items()
        total = len(items)
        if total == 0:
            return

        selected_name, selected_is_dir, selected_path, _ = items[
            self.nav.browser_selected
        ]
        parent_dir = os.path.dirname(selected_path)

        prompt = "Rename: "
        prompt_y = max_y - 1

        stdscr.move(prompt_y, 0)
        stdscr.clrtoeol()

        try:
            stdscr.addstr(prompt_y, 0, prompt[: max_x - 1])
        except curses.error:
            pass

        try:
            stdscr.timeout(-1)
            max_input_width = max(10, max_x - len(prompt) - 1)
            input_str = selected_name

            while True:
                stdscr.move(prompt_y, 0)
                stdscr.clrtoeol()
                display_str = prompt + input_str
                stdscr.addstr(prompt_y, 0, display_str[: max_x - 1])
                stdscr.refresh()

                key = stdscr.getch()
                if key in (10, 13, curses.KEY_ENTER):
                    break
                if key == 27:
                    input_str = ""
                    break
                if key in (curses.KEY_BACKSPACE, 127, 8):
                    if input_str:
                        input_str = input_str[:-1]
                elif 32 <= key <= 126 and len(input_str) < max_input_width:
                    input_str += chr(key)
        except KeyboardInterrupt:
            input_str = ""
        except Exception:
            input_str = ""
        finally:
            stdscr.timeout(40)
            self.nav.need_redraw = True

        new_name = input_str.strip()
        if not new_name or new_name == selected_name:
            return

        unique_name = self.nav.input_handler._get_unique_name(parent_dir, new_name)
        new_path = os.path.join(parent_dir, unique_name)

        try:
            os.rename(selected_path, new_path)
        except Exception as e:
            stdscr.addstr(
                prompt_y,
                0,
                f"Error renaming: {str(e)[: max_x - 20]}",
                curses.A_BOLD,
            )

            stdscr.clrtoeol()
            stdscr.refresh()
            stdscr.getch()
            return

        self.nav.notify_directory_changed(parent_dir)
        self.nav.status_message = (
            f"Renamed to {unique_name}" if unique_name != selected_name else "Renamed"
        )
